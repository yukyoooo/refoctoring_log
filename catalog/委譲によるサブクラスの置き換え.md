# 委譲によるサブクラスの置き換え

## 手順
1. コンストラクタの呼び出し元が多い場合は、まず[ファクトリ関数によるコンストラクタの置き換え](ファクトリ関数によるコンストラクタの置き換え.md)を適用する
2. 委譲用の空のクラスを作成する。そのコンストラクタはサブクラス固有のデータを受け取る。また、スーパークラスへの逆参照を受け取ることも多い
3. 委譲先オブジェクトを保持するフィールドをスーパークラスに追加する
4. サブクラスの生成処理を変更して、委譲用フィールドを委譲先クラスのインスタンスで初期化するようにする
   - これはファクトリ関数の中で実行できる。コンストラクタで正しい委譲先を確実に特定できる場合は、コンストラクタ内で実行しても良い
5. 委譲先クラスに移動するサブクラスのメソッドを選択する
6. 選択したメソッドに[関数の移動](関数の移動.md)を適用して、委譲先クラスに移動する。元の委譲を行うためのコードは削除しないこと
   - 選択したメソッドが委譲先に移動すべき要素を必要とする場合は、それらを移動する。スーパークラスに残すべき要素を必要とする場合は、スーパークラスを参照するフィールドを委譲先クラスに追加する
7. 元のメソッドにクラス外部からの呼び出しがある場合は、元の委譲を行うコードをサブクラスからスーパークラスに移動し、委譲先の存在を確認するガードを置く。外部呼び出しがない場合は、[デッドコードの削除](デッドコードの削除.md)を適用する
   - 複数のサブクラスがあり、その中のコードが重複し始めたら[スーパークラスの抽出](スーパークラスの抽出.md)を適用する。このとき、デフォルトの振る舞いが委譲先のスーパークラスに移されるなら、元のスーパークラスにあるすべての委譲を行うメソッドのガードは不要になる
8. テストする
9. サブクラスの全てのメソッドが移動されるまで繰り返す
10. サブクラスのコンストラクタの呼び出し元を全て見つけて、スーパークラスのコンストラクタを使用するように変更する
11. テストする
12. サブクラスに対して[デッドコードの削除](デッドコードの削除.md)を適用する

```js
class Order {
	get daysToShip() {
		return this._warehouse.daysToShip;
    }
}
class PriorityOrder extends Order {
	get daysToShip(){
		return this._priorityPlan.daysToShip;
    }
}
```
↓
```js
class Order {
	get daysToShip() {
		return (this._priorityDelegate)
            ? this._priorityDelegate.daysToShip
            : this._warehouse.daysToShip;
    }
}
class PriorityOrderDelegate {
	get daysToShip() {
		return this._priorityPlan.daysToShip
    }
}
```